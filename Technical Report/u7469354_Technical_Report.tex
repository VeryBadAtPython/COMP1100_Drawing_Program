\documentclass[11pt]{article}
\title{Technical Report\\ COMP1100 Assignment 1}
\author{Jacob Bos\\ ANU u7469354}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
	\newcolumntype{L}{>{\centering\arraybackslash}m{15cm}}
\usepackage{float}
\usepackage{multicol}
\setlength{\columnsep}{1cm}
\usepackage{setspace}
\usepackage{xcolor}

\newenvironment{smallpmatrix}
  {\left(\begin{smallmatrix}}
  {\end{smallmatrix}\right)}
 \newenvironment{smol}
  {\left(\begin{smallmatrix}}
  {\end{smallmatrix}\right)}


\usepackage[margin=2cm]{geometry}
\addtolength{\textheight}{-0.5cm}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\begin{document}
\maketitle
\pagenumbering{roman}
\setstretch{1.5}
\begin{center}
  Lab: Tuesday 11am\\
  Tutor: Abhaas Goyal
\end{center}
\tableofcontents
\newpage
\pagenumbering{arabic}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Introduction} 
This Technical report documents the structure of the assignment solution and offers a reflective analysis of design choices made and the results and structure of the testing regeme. The program is designed to take user inputs and produce a picture onscreen using the Haskell CodeWorld package. The Documentation section will purely describe the design of the solution. The analysis section will assess the design choices made and the specifications and assumptions that led to them. Finally the Testing section documents the testing regiment used for evaluation. 


%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Design Documentation}%Explanation of code workings, functions and structure.

\paragraph{Part 1} consists of three functions. The first function of Part 1 \verb|toolToLabel| in \verb|model View| case matches an input of a tool, ignoring the other tool properties to return a string output of instructions to the user on tool use. The second function \verb|nextColor| in \verb|module Controller| uses case matching to cycle through colours according to the following order
\begin{verbatim} Black  -> Red -> Orange -> Yellow -> Green -> Blue -> Purple -> White -> Black\end{verbatim}
Finally, the functon \verb|nextTool| in \verb|module Controller| cycles a particular imput of an empty tool to the next tool in the sequence also with empty parameters. It also uses case matching.

\paragraph{Part 2} Contains four functions the first of which, \verb|colourNameToColour| in \verb|module View| which case matches elements of the type \verb|ColourName| and returns the same colour in the type of \verb|Colour| which codeworld can interpret. The second function \verb|shapeToPicture| takes the information kept within the type \verb|Shape| and converts it to a codeworld \verb|Picture| that can be printed to the display. Where most inputs were case matched to equivilent the specifications of \verb|Rectangle| were through some vector algebra converted to a \verb|solidPolygon| of four points. The \verb|Cap| is a combination of the codeworld \verb|clipped| and \verb|circle| functions transposed as the user specifies. The third function \verb|colourShapeToPicture| takes input of the type \verb|colourShape| and returns the associated shape with the given colour in the type \verb|Picture|. The helper functions \verb|distance| and \verb|otherTriPoint| assisted implementation with the former used to calculate circle radi and the latter the third point of the isoscelies triangle. Finally, the function \verb|colourShapesToPicture| recursivly runs through an input of type \verb|[Shape]| and returns each member composed together as a composite \verb|Picture|. It returns an error message for unexpected inputs.

\paragraph{Part 3} consists of one key function and six helper functions. The main function \verb|handleEvent| cases on either keystroke inputs or mouse key inputs to produce the inteded picture output. Presses of backspace and delete calls the funtion \verb|deletePress| which removes the head of the list of shapes to remove the most recently added shape from the image. The spacebar input calls the function \verb|endPoly| that takes any list stored in type \verb|Tool| and then adds a codeworld polygon to the list of colourshapes. Key inputs of + or - call the functions \verb|scaleRect| and \verb|negScaleRect| respectivly that add or decrease the scaling factor stored in a rectangle tool. Mouse presses call the function \verb|pointPress| that cases on the type of shape tool being used to store the pressed point in the desired tool. Further the helper \verb|pointRel| is called upon mouse releases generally to complete a shape adding it to the list of shapes and returning an empty tool. There are two cases on \verb|CapTool| to determine if it is storing the second point or the y coordinate of the cutoff point.

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Reflection}
\paragraph{Part 1} used a case statement for all three functions as they were all nessisarially injective with a finite domain. Consequent to this there was no need to test the tructh of any statements. \verb|nextTool| used a wildcard on the final cast to catch any half completed shapes and avoid the program crashing and instead just returning the held tool.
\paragraph{Part 2} Whilst \verb|colourNameToColour| was a very simple case matching function the function \verb|shapeToPicture| is more complicated. It case matches on the tool used. For both the triangle and rectangle inputs the \verb|solidPolygon| function was used to create the associated picture due to the specifications of the input not aligning well to a unique CodeWorld  function. For the triangle the points used were the two given points and a third given by the function \verb|otherTriPoint| that calculated the other isosceles point. For rectangles some vector maths is used in teh definition to define the two other points as a translation of the first two points of a degree dictated by the scaling factor. The specifications for producing a cap required another nested case to determine if the cutoff was below the circle or not. if it was it would just return a circle, otherwise the desired cap would be produced. This was necessitated by the particular clip window and translations used. \verb|colourShapeToPicture| used a simple casing on the possible pairs of colourshapes to return the appropiiate coloured picture using the appropriate CodeWorld function. Finally it was nessisary to recurse through the list of colourshapes in the \verb|colourShapesToPicture| fucnction as the list could be of any length.


%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\subsection{Assumptions}%Describe assumptions you have made about how a user might use the program and how this has influenced your design decisions.
Due to a gap in the specifictions for \verb|handleEvent| it was assumed that the function \verb|pointRel| should re-initialise the scale factor of the rectangle tool at \verb|1.0| upon the completion of a rectangle on release of cursor. This is hoped to enhance functionality when a user has used an extreme value of the scale factor and wants to quickly return to a reasonable scale factor for the next rectangle input. For \verb|colourShapesToPicture| it was assumed that in case of an empty shapes list it should return a blank canvas, thus the prespecified codeworld function \verb|blank| was used.


%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\section{Testing}%How did I test the program focus on methodology and testing groups
\paragraph{Part 1}
Part 1 composed of the functions \verb|toolToLabel| \verb|nextTool| and \verb|nextColour| was tested using the provided cabal test run under the command \verb|cabal v2-test|. It passed \verb| 1 of 1 test suites|. Further simple tests were condcuted within development based on calling function inputs in the terminal to ensure the case matching was working in correspondence to the intended inputs.
\paragraph{Part 2} 

\paragraph{Part 3}



%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\end{document}